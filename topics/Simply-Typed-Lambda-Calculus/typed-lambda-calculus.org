#+TITLE: Typed Lambda Calculus
#+AUTHOR: Nitin John Raj

We learned untyped lambda calculus in [[../Untyped-Lambda-Calculus/untyped-lambda-calculus.org][Chapter 3: Untyped Lambda Calculus]]. In this chapter, we'll extend our definition of lambda calculus with a type system, similar to what we did in [[../Typed-Expressions/typed-expressions.org][Chapter 4: Typed Expressions]]. However, for the sake of brevity, we'll only cover booleans in this chapter.

* Types
  Simple types of our language is generated by this grammar:

  \[T := Bool\ |\ T \to T\]

  Here, /type constructor/ \[\to\] is right-associative. \[A \to B\] represents the type of function that maps type-A arguments to type-B results.

  
* Typing Relation
  In order to determine the type of argument an abstraction accepts, there are two ways of going about it.

  1. Annotation of the abstraction with the type of argument it accepts. (*explicit typing*)
  2. Inference of type through analysis of the body of the abstraction. (*implicit typing*)

  The return type of the abstraction can be inferred using the following typing rule:

  \[\frac{\Gamma, x : T_1 \vdash t : T_2}{\Gamma \vdash \lambda x : T_1.\ t : T_1 \to T_2}\]
 
  Let's break this down. 

  - The notation \[x : T\] means that variable x is of type T. It can also be written as \[x \in T\].
  - We also introduce the \[\vdash\] operator. The \[\vdash\] operator provides a set of assumptions made about the types of certain variables. For example, \[\Gamma \vdash t_1 : T_1\] can be read as "Under the set of typing assumptions \[\Gamma\], it can be inferred that \[t_1 : T_1\]." When the left-hand operand is missing from the \[\vdash\] operator, it means that we are working under an empty set of assumptions.

  Here, the set of typing assumptions is formally called a /typing context/, and is usually represented by \[\Gamma\]. An empty set of types is represented by \[\Phi\]; however, we usually just omit writing the typing context when working on an empty set of assumptions. The typing context can also be viewed as a typing relation mapping from variable identifiers to the types of data they represent i.e. \[\Gamma: V \to S_T\], where V is the set of all valid variable identifiers and \[S_T\] is the set of all valid types.

  With all the syntactic definitions out of the way, let's define the rules of the typing.

  T-ABS: \[\frac{\Gamma, x:T_1 \vdash t:T_2}{\Gamma \vdash (\lambda x:T_1.\ t) : T_1 \to T_2}\]

  T-VAR: \[\frac{x:T_1 \in \Gamma}{\Gamma \vdash x:T_1}\]

  T-APP: \[\frac{\Gamma \vdash t_1: T_1 \to T_2, \Gamma \vdash t_2: T_1}{\Gamma \vdash (t_1\ t_2): T_2}\]

  T-IF: \[\frac{\Gamma \vdash t_1: Bool, \Gamma \vdash t_2: T, \Gamma \vdash t_2: T}{\Gamma \vdash (if\ t_1\ then\ t_2\ else\ t_3): T}\]


* Properties of Typing
** Lemma: Inversion of the Typing Relation

   1. \[\Gamma \vdash x: T \implies x:T \in \Gamma\]

   2. \[\Gamma \vdash (\lambda x:T_1.\ t): R \implies \exists T_2(R = T_1 \to T_2 \iff \Gamma, x:T_1 \vdash t:T_2)\]

   3. \[\Gamma \vdash (t_1\ t_2): R \implies \exists T_1((\Gamma \vdash t_1: T_1 \to R) \wedge (\Gamma \vdash t_2: T_2))\]

   4. \[\Gamma \vdash true: R \implies R = Bool\]

   5. \[\Gamma \vdash false: R \implies R = Bool\]

   6. \[\Gamma \vdash (if\ t_1\ then\ t_2\ else\ t_3): R \implies \Gamma \vdash t_1: Bool, \Gamma \vdash t_2: R, \Gamma \vdash t_3: R\]

** Theorem: Uniqueness of Types
   \[\Gamma \vdash t : T_1, \Gamma \vdash t: T_2 \implies T_1 = T_2\]

** Lemma: Canonical Forms
   
   1. \[v: Bool \implies (v = true) \vee (v = false)\]

   2. \[v: T_1 \to T_2 \implies (v = \lambda x: T_1.\ t) \wedge (x: T_1 \vdash t: T_2)\]

** Theorem: Progress
   Let V be the set of all values. Then, \[\vdash t: T \implies (t \in V) \vee (\exists t'(t \to t'))\].

** Lemma: Permutation
   If \[\Delta\] is a permutation of \[\Gamma\], then \[\Gamma \vdash t: T \implies \Delta \vdash t: T\].

*** TODO Why is typing context defined as a sequence? (Permutation theorem seems pointless, doesn't it make more sense to use an unordered container, like a set, to represent a typing context?)

** Lemma: Weakening
   \[(\Gamma \vdash t: T) \wedge (x \notin dom(\Gamma)) \implies \Gamma, x: S \vdash t: T\]

** Lemma: Preservation of Types under Substitution
   \[(\Gamma, x: S \vdash t: T) \wedge (\Gamma \vdash s: S) \implies \Gamma \vdash [x \mapsto s]t: T\]

** Theorem: Preservation
   \[(\Gamma \vdash t: T) \wedge (t \to t') \implies \Gamma \vdash t': T\]


* The Curry-Howard Correspondence
  The type constructor (\[\to\]) comes with two rules:
  1. An /introduction rule/ describing how elements of the type can be /created/.
  2. An /elimination rule/ describing how elements of the type can be /evaluated/.

  This terminology arises from a connection between type theory and logic, observed by Curry and Howard. This connection is called the /Curry-Howard correspondence/ or the /Curry-Howard isomorphism/.

  | LOGIC                       | PROGRAMMING LANGUAGES               |
  |-----------------------------+-------------------------------------|
  | propositions                | types                               |
  | proposition \[P \supset Q\] | type \[P \to Q\]                    |
  | proposition \[P \wedge Q\]  | type \[P \times Q\]                 |
  | proof of proposition P      | term t of type P                    |
  | proposition P is provable   | type P is inhabited (bby some term) |
  |-----------------------------+-------------------------------------|

  Using this view, simply typed lambda calculus can be used as a proof checker of sorts, where reduction of a term corresponds to the logical operation of /cut elimination/.


* Erasure and Typability
  Most compilers do not keep the type annotations during runtime; they are used in the type-checking process (and in code generation for more advanced compilers), but not in the compiled form of the program. The removal of types gives rise to what is called an /erasure/.

** Erasure
   Erasure of a term is defined as follows:

   \[erase(x) = x\]
   \[erase(\lambda x: T.\ t) = \lambda x.\ erase(t)\]
   \[erase(t_1\ t_2) = erase(t_1)\ erase(t_2)\]

** Theorem: Preservation of Evaluation Semantics Under Erasure
   1. \[t \to t' \implies erase(t) \to erase(t')\]
   2. \[erase(t) \to m' \implies \exists t'(t \to t', erase(t') = m')\]

** Typability
   A term m of untyped lambda calculus is said to be typable under \[\lambda_\to\] if there exists some simply typed term t such that erase(t) = m and \[\Gamma \vdash t: T\].


* Exercises
** TODO The pure simply typed lambda calculus with no base types is actually degenerate, with no well-typed terms at all. Why?
** DONE Prove: \[f: Bool \to Bool \vdash f\ (if\ false\ then\ true\ else\ false): Bool\]
   By T-IF on false, true and false, (if false then true else false): Bool
   By T-APP, f (if false then true else false): Bool

** DONE Prove: \[f: Bool \to Bool \vdash \lambda x: Bool.\ f\ (if\ x\ then\ false\ else\ x): Bool \to Bool\]
   By observing the annotation, we know that x: Bool.
   By T-IF on x, false and x, (if x then false else x): Bool
   By T-APP on f and if x then false else x, f (if x then false else x): Bool
   By T-ABS on that, \[\lambda x: Bool.\ f\ (if\ x\ then\ false\ else\ x): Bool\]

** DONE Find a context under where f x y: Bool.
   Given \[f: Bool \to Bool\].
   \[\Gamma = \{x: Bool \to Bool, y: Bool\}\]

** DONE Prove or disprove: \[t \to t' \wedge \Gamma \vdash t': T \implies \Gamma \vdash t: T\]
   Again, this might not hold if t is not well-typed. The evaluation relation is independent of types.
