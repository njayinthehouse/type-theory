#+TITLE: Q REPL
#+AUTHOR: Nitin John Raj

* Concrete Syntax
  The concrete syntax for the untyped language is given below. here, t is a metavariable representing the terms of the language. =error= is a term added for runtime errors, to prevent the interpreter from getting stuck.

  t ::= true | false | if t then t else t | 0 | succ t | pred t | iszero t | error

* Abstract Syntax
  The abstract syntax for the language is given by metavariable e below.

  e ::= VTrue | VFalse | IfThenElse e e e | VZero | Succ e | Pred e | IsZero e | Error

#+NAME: ast
#+BEGIN_SRC haskell
  data Expression = VTrue
                  | VFalse
                  | IfThenElse Expression Expression Expression
                  | VZero
                  | Succ Expression
                  | Pred Expression
                  | IsZero Expression
                  | Error
#+END_SRC

* Lexer
  We use Haskell's record syntax and the constructor =emptydef= from the =Text.ParserCombinators.Parsec.Language= package to define the tokens of the language. Using the =LanguageDef= structure so created, we build a lexer using =makeTokenParser= from the =Text.ParserCombinators.Parsec.Tokens= package. 

#+NAME: lexerdeps
#+BEGIN_SRC haskell
  import Text.ParserCombinators.Parsec
  import Text.ParserCombinators.Parsec.Expr
  import Text.ParserCombinators.Parsec.Language
  import qualified Text.ParserCombinators.Parsec.Token as Token
#+END_SRC

#+NAME: language_def
#+BEGIN_SRC haskell

#+END_SRC
