* Formal Syntactic and Semantic Definitions of Grammar

** Syntax

   Syntax is the set of grammatical rules that a language follows.
   To elucidate this concept, let's define a quick untyped language and observe the different ways of expressing its syntax.

*** Definition, by Context Free Grammar

  \[t ::=\]
       \[true\] (constant true)
       \[false\] (constant false)
       \[if \hspace{1mm} t \hspace{1mm} then \hspace{1mm} t \hspace{1mm} else \hspace{1mm} t\] (conditional)
       \[0\] (constant 0)
       \[succ \hspace{1mm} t\] (successor)
       \[pred \hspace{1mm} t\] (predecessor)
       \[iszero \hspace{1mm} t\] (zero test)

  The conventions used in this grammar is similar to the Backus-Naur Form of expressing grammars. Let's explain how this works.

  Here, \[t\] is a /metavariable/ representing a /term/ of the language. \[t\] can be replaced by any of the expressions following it. Note that some of the right hand expressions also contain metavariable \[t\], which can be replaced even within those expressions according to the same rules. 

  Let's define this language more rigorously.

*** Definition, by Induction: Terms \[T\]
    
    1. \[\{true, false, 0\} \subseteq T\]

    2. if \[t_1 \in T\] then \[\{succ\ t_1, pred\ t_1, iszero\ t_1\} \subseteq T\]

    3. if \[t_1, t_2, t_3 \in T\] then \[(if\ t_1\ then\ t_2\ else\ t_3) \in T\]

*** Definition, by Inference Rules: Terms \[T\]

    1. \[true \in T\]

    2. \[false \in T\]

    3. \[0 \in T\]

    4. \[\frac{t_1 \in T}{succ\ t_1 \in T}\]

    5. \[\frac{t_1 \in T}{pred\ t_1 \in T}\]

    6. \[\frac{t_1 \in T}{iszero\ t_1 \in T}\]

    7. \[\frac{t_1 \in T\ \ t_2 \in T\ \ t_3 \in T}{if\ t_1\ then\ t_2\ else\ t_3 \in T}\]

    (Note: It is implicitly understood that \[T\] is the smallest set that abides by these rules.)

*** Concrete Definition: Terms \[S\]

    1. \[S_0 = \phi\]
   
    2. \[S_{i + 1} = \{true, false, 0\} \cup \{succ\ t_1, pred\ t_1, iszero\ t_1\ |\ t_1 \in S_i\} \cup \{if\ t_1\ then\ t_2\ else\ t_3\ |\ t_1, t_2, t_3 \in S_i\}\]

    3. \[S = \bigcup\limits_{i} S_i\]

*** Prove: \[T = S\]

    Let the definition by inference rules of the terms be \[p\] and the concrete definition be \[q\].

    /First, let's show that \[p(S)\] is true./
   
    \[S_1 = \{true, false, 0\}\], thus the first 3 rules of \[p\] hold for \[S_0\].
    \[\therefore p_{1,2,3}(S)\] is true.

    Now consider \[t_1 \in S\].
    But if \[t_1 \in S\], from \[q_3\], we can say that \[\exists k \in \mathbb{N}\ (t_1 \in S_k)\].
    From \[q_2\], \[S_{k + 1} = \{true, false, 0\} \cup \{succ\ t_1, pred\ t_1, iszero\ t_1\ |\ t_1 \in S_k\} \cup \{if\ t_1\ then\ t_2\ else\ t_3\ |\ t_1, t_2, t_3 \in S_k\}\].
    But \[S_{k+1} \subseteq S\].
    \[\therefore p_{4,5,6,7}(S)\] is true.

    \[\therefore p(S)\] is true.

    /Now, we just need to prove that \[S\] is the smallest set that obeys these rules./
    If this is true, then \[\forall S'\ (p(S') \implies S \subseteq S')\].

    Consider \[S_j \in S'\ |\ j < i\] for some i.

    Case 1: \[i = 0\]
      \[S_j = S_0 = \phi\]
      But trivially, \[\phi \subseteq S'\]
      \[\therefore S_0 \subseteq S'\]

    Case 2: \[i > 0\]
      Let \[i = j + 1\].
      For \[S_{j + 1}\], \[q_2\] applies.
      Consider \[t_0 \in S_{j + 1}\]

      Subcase 1: \[t_0\] is constant.
        Then by \[p_{1, 2, 3}\], \[t_0 \in S'\].
	 
      Subcase 2: \[t_0\] is of the form \[succ\ t_1\], \[pred\ t_1\] or \[iszero\ t_1\]
        Then \[t_1 \in S_j\].
	By our induction hypothesis, \[t_1 \in S'\]
	\[\therefore\], by \[p_{4,5,6}\], \[t_0 \in S'\]

      Subcase 3: \[t_0\] is of the form \[if\ t_1\ then\ t_2\ else\ t_3\]
        Similar to subcase 2, \[t_0 \in S'\]

    Thus, we prove that in all subcases, \[t_0 \in S_{j + 1} \implies t_0 \in S'\].

    Thus, we prove that \[\forall i > 0\ (S_j \subseteq S')\]
    But \[S = \bigcup\limits_i S_i\]
    \[\therefore S \subseteq S'\]

    \[\therefore\ S\] is the smallest set that satisfies \[p\].

    \[\therefore\ S = T\]


** Induction on Terms

   By induction on terms, we can define many useful functions.

*** Set of Constants in a Term
    
    \[Consts: T \to \{true, false, 0\}\]
    \[Consts(true) = \{true\}\]
    \[Consts(false) = \{false\}\]
    \[Consts(0) = \{0\}\]
    \[Consts(succ\ t_0) = Consts(t_0)\]
    \[Consts(pred\ t_0) = Consts(t_0)\]
    \[Consts(iszero\ t_0) = Consts(t_0)\]
    \[Consts(if\ t_1\ then\ t_2\ else\ t_3) = Consts(t_1) \cup Consts(t_2) \cup Consts(t_3)\]

*** Size of a Term

    The number of nodes in its abstract syntax tree.
    \[size: T \to \mathbb{N}\]
    \[size(true) = 1\]
    \[size(false) = 1\]
    \[size(0) = 1\]
    \[size(succ\ t_0) = 1 + size(t_0)\]
    \[size(pred\ t_0) = 1 + size(t_0)\]
    \[size(iszero\ t_0) = 1 + size(t_0)\]
    \[size(if\ t_1\ then\ t_2\ else\ t_3) = 1 + size(t_1) + size(t_2) + size(t_3)\]

*** Depth of a Term

    The maximum depth of its abstract syntax tree.
    \[depth: T \to \mathbb{N}\]
    \[depth(true) = 1\]
    \[depth(false) = 1\]
    \[depth(0) = 1\]
    \[depth(succ\ t_0) = 1 + depth(t_0)\]
    \[depth(pred\ t_0) = 1 + depth(t_0)\]
    \[depth(iszero\ t_0) = 1 + depth(t_0)\]
    \[depth(if\ t_1\ then\ t_2\ else\ t_3) = 1 + max(depth(t_1), depth(t_2), depth(t_3))\]    

*** Theorem: Principle of Induction on Terms

    If \[P: T \to \{TRUE, FALSE\}\]

    1. Induction on Depth:
       \[\forall r, s \in T \hspace{1mm} (P(r) \wedge depth(r) < depth(s) \implies P(s))\]

    2. Induction on Size:
       \[\forall r, s \in T \hspace{1mm} (P(r) \wedge size(r) < size(s) \implies P(s))\]

    3. Structural Induction:
       \[\forall r, s \in T \hspace{1mm} (P(r) \wedge (r\] is a subterm of \[s) \implies P(s))\]



** Semantics

   Semantics define the meaning of the terms of a language.

*** Types of Semantics

    The meaning of a language can be defined using different types of semantics.

    1. Operational Semantics:
       - Expressed via abstract state machines[fn:1]
       
    2. Denotational Semantics:
       - Expressed at a higher level of abstraction using mathematical objects

    3. Axiomatic Semantics:
       - Defined via a set of logical laws

    Pierce has used operational semantics for his book, so we'll be sticking to those for the purpose of this tutorial. Operational semantics is highly used today, as the other two abstract semantic forms were found to have problems with representation. See the tangential topics for more information on those.


** Examples of Evaluation

   Let's define a few language similar to the one we defined when learning what syntax is. For these language, we need to define:
   - a set of valid expressions
   - a set of valid end values
   - a means of reducing non-value terms

*** Language Q

    The first language will only deal in boolean expressions.

**** Syntax

     Here, \[t\] is the metavariable representing valid terms, and \[v\] represents valid end states.
     
     \[t ::= \]
         \[true\]
	 \[false\]
	 \[if\ t\ then\ t\ else\ t\]

     \[v ::= \]
         \[true\]
	 \[false\]

**** Semantics

     We shall be using one-step operational semantics.

     E-IF_TRUE:  \[if\ true\ then\ t_1\ else\ t_2\ \to t_1\]

     E-IF_FALSE: \[if\ false\ then\ t_1\ else\ t_2 \to t_2\]

     E-IF:       \[\frac{t_1 \to t_1'}{if\ t_1\ then\ t_2\ else\ t_3 \to if\ t_1'\ then\ t_2\ else\ t_3}\]

**** A Deeper Look     
     
     There are many points of interest here. What the rules say are fairly straightforward:
     1. E-IF_TRUE says that if the first subterm is true, then the second subterm is the return value.
     2. E-IF_FALSE says that if the first subterm is false, then the third subterm is the return value.
     3. E-IF says that if the first subterm \[t_1\] can be reduced to \[t_1'\], then the first subterm must be reduced for further evaluation.

     Note that there is no rule for reducing the second and third subterms within a term of type \[if\ t\ then\ t\ else\ t\]. E-IF allows the first subterm to be reduced, but the second and third are untouched.

     Thus, the rules help devise an /evaluation strategy/, or an /order of precedence/ of evaluation.
     



** Tangential Topics of Interest

   - Plotkin's /Structural Operational Semantics/ (1981)
   - Kahn's /Natural Semantics/ (1987)
   - Milner's work on CCS (1980, 1989, 1999)

* Footnotes

[fn:1] An abstract state machine is characterized by:
       - A set of states
       - A transition relation that maps states to other states given an input
       - A set of goal states
